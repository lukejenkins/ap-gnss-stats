# AI Rules for ap-gnss-stats

Every time you choose to apply a rule(s), explicitly state the rule(s) in the output. You can abbreviate the rule description to a single word or phrase.

This project is to assist network administrators with the GNSS (Global Navigation Satellite System) statistics generated by Cisco Wi-Fi Access Points.
- This project should start with a reusable python library that is for parsing the output from the cli command `show gnss info`.
  - There will be public example files in the repository to use for development and testing. These will have been anonymized to some degree.
  - There will be a private examples directory (that is included in the .gitignore file) for users to place additional logs to test against.
  - For this first phase, we will write a python program that reads one or more log files, and using the library we're writing, parses out all of the desired information.
    - The JSON data should include
      - The name and version of the CLI program creating the record.
      - The name and versions of the parsing library used for the output.
      - A timestamp of the current time.
      - The filename, file created timestamp, and file modified timestamp of the file that the record was parsed from.
    - This program should generate a JSON file that includes all of the parsed data for each AP.
    - The filename of the JSON file should include the hostname of the AP and a timestamp parsed from the log file.
    - There will be an option to create a log file that includes all of the debuging output per log file provided to the program.
- The second phase will be to write another program that uses netmiko to connect to an AP such as a Cisco CW9166i AP via SSH.
  - This program then will run the `show gnss info` CLI command in the EXEC shell to gather live data.
  - This program will then use the same library as in the first phase to parse the output from the command.
    - The JSON data should include
    - The name and version of the CLI program creating the record.
    - The name and versions of the parsing library used for the output.
    - A timestamp of the current time.
    - The hostname or IP of the AP being connected to.
  - There will be an option to create a full log of all SSH traffic for each session.
    - The filename of this log file should include the hostname of the AP and a timestamp.
  - This program should generate a JSON file that includes all of the parsed data for each AP.
- The third phase will be to write a program to push the parsed JSON from an SSH session to an instance of Prometheus.
- There may be additional phases added.
- For all libraries and programs, there will be options to turn on debugging to the CLI so that the user can see what the program is doing.


## CODING_PRACTICES

### Guidelines for SUPPORT_LEVEL

#### SUPPORT_BEGINNER

- When running in agent mode, execute up to 3 actions at a time and ask for approval or course correction afterwards.
- Write code with clear variable names and include explanatory comments for non-obvious logic. Avoid shorthand syntax and complex patterns.
- Provide full implementations rather than partial snippets. Include import statements, required dependencies, and initialization code.
- Add defensive coding patterns and clear error handling. Include validation for user inputs and explicit type checking.
- Suggest simpler solutions first, then offer more optimized versions with explanations of the trade-offs.
- Briefly explain why certain approaches are used and link to relevant documentation or learning resources.
- When suggesting fixes for errors, explain the root cause and how the solution addresses it to build understanding. Ask for confirmation before proceeding.
- Offer introducing basic test cases that demonstrate how the code works and common edge cases to consider.


### Guidelines for DOCUMENTATION

#### DOC_UPDATES

- Update relevant documentation in /docs when modifying features
- Keep README.md in sync with new capabilities
- Maintain changelog entries in CHANGELOG.md


### Guidelines for VERSION_CONTROL

#### GITHUB

- Use pull request templates to standardize information provided for code reviews
- Implement branch protection rules for {{protected_branches}} to enforce quality checks
- Configure required status checks to prevent merging code that fails tests or linting
- Use GitHub Actions for CI/CD workflows to automate testing and deployment
- Implement CODEOWNERS files to automatically assign reviewers based on code paths
- Use GitHub Projects for tracking work items and connecting them to code changes


### Guidelines for ARCHITECTURE

#### ADR

- Create ADRs in /docs/adr/{name}.md for:
- 1) Major dependency changes
- 2) Architectural pattern changes
- 3) New integration patterns
- 4) Database schema changes


## DEVOPS

### Guidelines for CI_CD

#### GITHUB_ACTIONS

- Check if `package.json` exists in project root and summarize key scripts
- Check if `.nvmrc` exists in project root
- Check if `.env.example` exists in project root to identify key `env:` variables
- Always use terminal command: `git branch -a | cat` to verify whether we use `main` or `master` branch
- Always use `env:` variables and secrets attached to jobs instead of global workflows
- Always use `npm ci` for Node-based dependency setup
- Extract common steps into composite actions in separate files
- Once you're done, as a final step conduct the following: for each public action always use <tool>"Run Terminal"</tool> to see what is the most up-to-date version (use only major version) - extract tag_name from the response:
- ```bash curl -s https://api.github.com/repos/{owner}/{repo}/releases/latest ```


## TESTING

### Guidelines for UNIT

#### PYTEST

- Use fixtures for test setup and dependency injection
- Implement parameterized tests for testing multiple inputs for {{function_types}}
- Use monkeypatch for mocking dependencies



## Code Style and Structure

- Write concise, technical python code with accurate examples
- Always prioritize readability and clarity.
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Use the `typing` module for type annotations (e.g., `List[str]`, `Dict[str, int]`).
- Break down complex functions into smaller, more manageable functions.
- Write code with good maintainability practices, including comments on why certain design decisions were made.
- Handle edge cases and write clear exception handling.
- For libraries or external dependencies, mention their usage and purpose in comments.
- Use consistent naming conventions and follow language-specific best practices.
- Write concise, efficient, and idiomatic code that is also easily understandable.

## Tech Stack

- Python 3.x
- netmiko
- dotenv

## Naming Conventions

- Use snake_case for variable and function names.
- Use CamelCase for class names.
- Follow PEP 8 style guidelines.

## Error Handling

- Implement proper error boundaries
- Log errors appropriately for debugging
- Provide user-friendly error messages
- Handle network failures gracefully

## Git Usage

Commit Message Prefixes:

- "fix:" for bug fixes
- "feat:" for new features
- "perf:" for performance improvements
- "docs:" for documentation changes
- "style:" for formatting changes
- "refactor:" for code refactoring
- "test:" for adding missing tests
- "chore:" for maintenance tasks

Rules:

- Use lowercase for commit messages
- Keep the summary line concise
- Include description for non-obvious changes
- Reference issue numbers when applicable

## Documentation

- Provide docstrings following PEP 257 conventions.

## Development Workflow

- Use proper version control
- Implement proper code review process
- Test in multiple environments
- Follow semantic versioning for releases
- Maintain changelog
